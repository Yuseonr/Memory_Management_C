3 sep 2025
Structs

--------------------------------L1 : Structs --------------------------------

example of the syntax:

struct Human {
    int age;
    char *name;
    int is_alive;
};

--------------------------------L2 : Intializers --------------------------------

Initializers

struct City {
  char *name;
  int lat;
  int lon;
};

Zero Initializer
int main() {
  struct City c = {0};
}

Positional Initializer
int main() {
  struct City c = {"San Francisco", 37, -122};
}

Designated Initializer
It's easier to read (has the field names)
If the fields change, you don't have to worry about breaking the ordering
int main() {
  struct City c = {
    .name = "San Francisco",
    .lat = 37,
    .lon = -122
  };
}

Accessing Fields
Accessing a field in a struct is done using the . operator. For example:

struct City c;
c.lat = 41; // Set the latitude
printf("Latitude: %d", c.lat); // Print the latitude

--------------------------------L3 : Scaling Coordinate --------------------------------

Remember how we can not return multiple values from a function in C? We can't do this:

int, char * become_older(int age, char *name) {
  return age + 1, name;
}

However, we can accomplish effectively the same thing by returning a struct:

struct Human become_older(int age, char *name) {
  struct Human h = {.age = age, .name = name};
  h.age++;
  return h;
}

--------------------------------L4 : Typedef --------------------------------

By now, you're probably tired of typing struct Coordinate over and over again, 
and you're wondering "How can I make my struct types easier to write, like int?"

Good news! C can do this with the typedef keyword.

struct Pastry {
    char *name;
    float weight;
};

This can also be written as:

typedef struct Pastry {
    char *name;
    float weight;
} pastry_t;

Now, you can use pastry_t wherever before you would have used struct Pastry.

The _t at the end is a common convention to indicate a type.

In fact, you can optionally skip giving the struct a name:

typedef struct {
    char *name;
    float weight;
} pastry_t;

pastry_t muffin = {"Muffin", 0.3};

--------------------------------L5 : Sizeof --------------------------------

Sizeof
sizeof can be used to view the size of a type 
But this isn't just true of builtin types like int or float, 
you can also use it to find out the size of structs!

printf("Size of coordinate_t: %zu bytes\n", sizeof(coordinate_t));

Structs are stored contiguously in memory one field after another. Take this struct:

typedef struct Coordinate {
    int x;
    int y;
    int z;
} coordinate_t;

Assuming int is 4 bytes, the memory layout for coordinate_t would look like:

+-----------------------------------+
|         Coordinate Struct         |
+-----------+-----------+-----------+
|  field x  |  field y  |  field z  |
+-----------+-----------+-----------+
| 4 bytes   | 4 bytes   | 4 bytes   |
+-----------+-----------+-----------+

Mixed Type Structs
typedef struct Human{
    char first_initial;
    int age;
    double height;
} human_t;

padding doing here?

It turns out that CPUs don't like accessing data that isn't aligned (incredible oversimplification alert, since obviously CPUs don't have feelings (yet)),
so C inserts padding to maintain alignment (e.g. every 4 bytes in this example).

Huge caveat: these layouts can vary depending on the compiler and system architecture.


--------------------------------L6 : Struct Padding --------------------------------

Struct Padding
There are a bunch of complicated rules and heuristics that different compilers use to determine how to lay out your structs. But to oversimplify:

The fields of a struct are laid out in memory contiguously (next to each other)
Structs can vary in size depending on how they are laid out.
C is a language that aims to give tight control over memory, so the fact that you can control the layout of your structs is a feature, not a bug.

Compilers + modern hardware + optimizations + skill issues 
means that sometimes what you think the computer is going to do isn't exactly what it actually does. 
That said, C is designed to get you close to the machine and allows you to dig in and figure out what's going on if you want to for a specific compiler or architecture.


As a rule of thumb, ordering your fields from largest to smallest will help the compiler minimize padding:

typedef struct {
  char a;
  double b;
  char c;
  char d;
  long e;
  char f;
} poorly_aligned_t;

typedef struct {
  double b;
  long e;
  char a;
  char c;
  char d;
  char f;
} better_t;


The difference you're seeing between your Mac (24 bytes) and the online playground (16 bytes) is likely due to different pointer sizes:

Online playground: Probably running on a 32-bit system or configured for 32-bit compilation, where pointers are 4 bytes
Your Mac: Running on a 64-bit system, where pointers are 8 bytes

The test passes because your struct is optimally arranged for your system architecture. The padding is minimized given the constraints of your 64-bit Mac environment. This is perfectly normal and expected behavior!

This is why C code can behave differently across different architectures - it's one of the "features" of working close to the hardware level.