31/08/2025
C Basics

--------------------------------L1 : Welcome To Memory Management --------------------------------

Goals of This Course : 

Understand how and where programs store data in memory. 
Variables, functions and objects don't get to exist for free. 
Where do they live as your code runs?

Learn how to make programs more efficient. 
Most performance related problems in backend software are memory related (at least in my experience). 
Learn how it all works so you can troubleshoot and optimize.

Practice programming in a lower-level language. 
C gets you much closer to the hardware than Python, JavaScript, or Go. 
By writing C, you'll learn a lot about how software works closer to the metal.

Learn about garbage collection (and build your own). 
You will likely work in a garbage collected language at some point, whether that's Python, Go, JavaScript or something else. 
Best to understand what trade-offs are being made.

Prerequisites

Coding experience: 
You should be comfortable writing code in at least one other language, like Python, JavaScript, or Go.

CS Basics: 
We expect that you understand basic algorithms, data structures, OOP and FP concepts.

--------------------------------L2 : C Program Structure --------------------------------

python3 slow_program.py

The Python interpreter then executes that file top-to-bottom.
If you have a print() at the top level, then it will print something.

The entire file is interpreted line by line, but that's not how C works.

Simplest C Program
The simplest C program is essentially:

int main() {
    return 0;
}

But a lot is happening here...

A function named main is always the entry point to a C program (unlike Python, which enters at the top of the file).

int is the return type of the function and is short for "integer". 
Because this is the main function, the return value is the exit code of the program. 0 means success, anything else means failure.

You'll find a lot of abbreviations in C because : 
1. programmers are lazy
2. it used to matter how many bytes your source code was.

The opening bracket, { is the start of the function's body (C ignores whitespace, so indentation is just for style, not for syntax)

return 0 returns the 0 value (an integer) from the function. Again, this is the exit code because it's the main function.
0 represents "nothing bad happened" as a return value.

The pesky ; at the end of return 0; is required in C to terminate statements.

The closing bracket, } denotes the end of the function's body.

<->

Print

It feels very different coming from Python, but printing in C is done with a function called 
printf from the stdio.h (standard input/output) library with a lot of weird formatting rules. 
To use it, you need an #include at the top of your file:

#include <stdio.h>

Then you can use printf from inside a function:

printf("Hello, world!\n");

Notice the \n: it's required to print a newline character (and flush the buffer in the browser), 
which print() in Python does automatically.

In case you're wondering, the f in printf stands for "print formatted".

--------------------------------L4 : C is Compiled --------------------------------

This Python code prints "starting" before it crashes:

print("starting")
func_that_doesnt_exist("uh oh")
print("finished")

But in C, it crashes before it can even run. If there's a problem, the compiler tells us before the program even starts.

Now... C doesn't tell us about all the possible problems (read: skill issues) that might arise in our program. 
But it does tell us about some of them.

--------------------------------L5 : Comments --------------------------------

In C, there are two ways to write comments:

// This is a single-line comment

/*
This is a multi-line comment
I can just keep adding lines
and it will still be a comment
*/

--------------------------------L6 : Basic Types --------------------------------

Basic Types
int - An integer
float - A floating point number
char - A character
char * - An array of characters (more on this later... if you think about it, sounds kinda like a string doesn't it?)

--------------------------------L7 : Strings --------------------------------

C strings are just arrays (like lists) of characters
this is how you get a "string" in C:

char *msg_from_dax = "You still have 0 users";

char * means string. Also note that it is required to use double quotes ". Single quotes (') make char, not char *.

--------------------------------L8 : Printing Variables --------------------------------

Instead of:

print(f"Hello, {name}. You're {age} years old.")

We have to tell C how we want particular values to be printed using "format specifiers".

Common format specifiers are:

%d - digit (integer)
%c - character
%f - floating point number
%s - string (char *)

printf("Hello, %s. You're %d years old.\n", name, age);

--------------------------------L9 : Compilation {types} --------------------------------

In C, changing the type of an existing variable is not allowed:

int main() {
    char *max_threads = "5";

    // call badcop
    // this is illegal
    max_threads = 5;
}

--------------------------------L10 : Variables --------------------------------

As we talked about, variables cannot change types:

int main() {
    int x = 5;
    float x = 3.14; // error
}

However, a variable's value can change:

int main() {
    int x = 5;
    x = 10; // this is ok
    x = 15; // still ok
}

--------------------------------L11 : Constants --------------------------------

So a variable's value can change:

int main() {
    int x = 5;
    x = 10; // this is ok
}

But what if we want to create a value that can't change? We can use the const type qualifier.

int main() {
    const int x = 5;
    x = 10; // error
}

--------------------------------L12 : Functions --------------------------------

In C, functions specify the types for their arguments and return value.

float add(int x, int y) {
    return (float)(x + y);
}

The first type, float is the return type.
add is the name of the function.
int x, int y are the parameters to the function, and their types are specified.
x + y adds the two arguments together.
(float) casts the result to a float.
We'll talk more about what cast means later, and the rules for casting to and from certain types.
The simple version is that it instructs C to treat the result of x + y as a float.

--------------------------------L13 : Void --------------------------------

There are two primary ways you'll use void:

To explicitly state that a function takes no arguments:

int get_integer(void) {
    return 42;
}

When a function doesn't return anything:

void print_integer(int x) {
    printf("this is an int: %d", x);
}

void in C is not like None in Python. It's not a value that can be assigned to a variable. 
It's just a way to say that a function doesn't return anything or doesn't take any arguments.

--------------------------------L14 : Unit Test --------------------------------

Unit Tests
Up to this point, we've been checking the standard output of your code against our expected output. 
Now that you're familiar with functions, most of the lessons will be graded using unit tests.

µnit
In particular, we'll be using the µnit (munit) testing framework. It's a simple, lightweight testing framework for C.

You should be debugging your code using the Run button. You should be adding printf() statements to your code to make sure it's doing what you think it's doing at different points in the code.

Write a line to calculate a value
printf() the value you calculated
Run the code
Did it print what you expected? If not, fix it
Repeat

Open exercise.h and you'll see the function prototype (signature) of the function you need to write. In C:

.c files contain the implementation (c code).
.h files are header files that contain the function prototypes.
To import code from another file, you include the .h file.

exercise.c includes exercise.h.
main.c includes exercise.h.
This allows main.c to call the functions implemented in exercise.c

--------------------------------L15 : Math Operators --------------------------------

All the same operators you'd expect exist in C:

x + y;
x - y;
x * y;
x / y;

If you're coming from Python, +=, -=, *=, /= are all the same.

In addition, there are also the ++ and -- operators:

x++; // += 1
x--; // -= 1

These increment (++) and decrement (--) operators can be used in two forms: postfix and prefix.

Postfix (x++ or x--): The value of x is used in the expression first, and then x is incremented or decremented. For example:

int a = 5;
int b = a++; // b is assigned 5, then a becomes 6

Prefix (++x or --x): x is incremented or decremented first, and then the new value of x is used in the expression. For example:

int a = 5;
int b = ++a; // a becomes 6, then b is assigned 6

--------------------------------L16 : If Statements --------------------------------

Basic syntax:

if (x > 3) {
    printf("x is greater than 3\n");
}

if/else/else if are also available:

if (x > 3) {
    printf("x is greater than 3\n");
} else if (x == 3) {
    printf("x is 3\n");
} else {
    printf("x is less than 3\n");
}

Janky Syntax
You can write an if statement without braces if you only have one statement in the body:

if (x > 3) printf("x is greater than 3\n");

--------------------------------L17 : Ternary --------------------------------

C has a ternary operator:

int a = 5;
int b = 10;
int max = a > b ? a : b;
printf("max: %d\n", max);
// max: 10

a > b ? a : b

The entire line is a single expression that evaluates to one value. Here's how it works:

a > b is the condition
a is the final value if the condition is true
b is the final value if the condition is false
The entire expression (a > b ? a : b) evaluates to either a or b, which is then assigned to max in our example.
Ternaries are a way to write a simple if/else statement in one line.

--------------------------------L18 : Type Sizes --------------------------------

Type Sizes
In C, the "size" (in memory) of a type is not guaranteed to be the same on all systems. 
That's because the size of a type is dependent on the system's architecture. 
For example, on a 32-bit system, the size of an int is usually 4 bytes, 
while on a 64-bit system, the size of an int is usually 8 bytes 
of course, you never know until you run sizeof with the compiler you plan on using.

Basic C Types and Sizes:
char
Size: 1 byte
Represents: Single character.
Notes: Always 1 byte, but can be signed or unsigned.
float
Size: 4 bytes
Represents: Single-precision floating-point number.
double
Size: 8 bytes
Represents: Double-precision floating-point number.

--------------------------------L19 : Sizeof --------------------------------

C gives us a way to check the size of a type or a variable: sizeof

size_t
The size_t type is a special type that is guaranteed to be able to represent the size of the largest possible object 
in the target platform's address space

--------------------------------L20 : For loop --------------------------------

For Loop
A for loop in C is a control flow statement for repeated execution of a block of code. 
Very similar to Python, but with a different syntax.

The syntax of a for loop in C consists of three main parts:

Initialization
Condition
Final-expression.

Syntax
for (initialization; condition; final-expression) {
    // Loop Body
}

Parts of a for Loop

Initialization
Executed only once at the beginning of the loop.
Is typically used to initialize the loop counter: int i = 0; for example

Condition
Checked before each iteration.
If true, execute the body. If false, terminate the loop
Often checks to ensure i is less than some value: i < 5; for example

Final-expression
Executed after each iteration of the loop body.
Can be used to update the loop counter or run any other code: i++ for example

Loop Body
The block of code that is executed while the condition is true.

example :
for (int i = 0; i < 5; i++) {
    printf("%d\n", i);
  }
--------------------------------L21 : While loop --------------------------------

Syntax
while (condition) {
    // Loop Body
}

Parts of a while Loop

Condition
Checked before each iteration.
If true, execute the body. If false, terminate the loop

Loop Body
The block of code that is executed while condition is true.

example :
int i = 0;
    while (i < 5) {
        printf("%d\n", i);
        i++;
    }

Key Points
The condition is evaluated before the execution of the loop body.
If the condition is false initially, the loop body will never even start.
If the condition never becomes false, you will get an infinite loop.

--------------------------------L22 : Do While loop --------------------------------

do while loop checks the condition after executing the loop body, so the loop body is always executed at least once.

Syntax
do {
    // Loop Body
} while (condition);

Parts of a do while Loop

Loop Body
The block of code that is executed before checking the condition, and then repeatedly as long as the condition is true.

Condition:
Checked after each iteration.
If true, execute the body again.
If false, terminate the loop

example :
int i = 0;
do {
    printf("i = %d\n", i);
    i++;
} while (i < 5);

The do while loop guarantees that the loop body is executed at least once, even if the condition is false initially.
The most common scenario you will see a do-while loop used is in C macros 
- they let you define a block of code and execute it exactly once in a way that is safe across different compilers, 
and ensures that the variables created/referenced within the macro do not leak to the surrounding environment.

--------------------------------L23 : Pragma once and Header guards --------------------------------

Pragma Once and Header Guards
We saw how .h header files are used in a previous lesson, but before we go further let's talk about a potential issue you might run into: multiple inclusions. 
If the same header file gets included more than once, you can end up with some nasty errors caused by redefining things like functions or structs.

Pragma Once
One simple solution (and the one we'll use for the rest of this course) is #pragma once. 
Adding this line to the top of a header file tells the compiler to include the file only once, even if it's referenced multiple times across your program.

// my_header.h

#pragma once

struct Point {
    int x;
    int y;
};

Header Guards
Another common way to avoid multiple inclusions is with include guards, which use preprocessor directives like this:

#ifndef MY_HEADER_H
#define MY_HEADER_H

// some cool code

#endif

Example:

// common.h
float get_average(int x, int y, int z);

// A.h
#include "common.h"
// ...A-specific declarations

// B.h
#include "common.h"
// ...B-specific declarations

Then in one .c file:

// main.c
#include "A.h"
#include "B.h"

int main(void) { return 0; }

If include guards/pragma once are missing from common.h, the declarations from common.h get included twice into main.c, 
which can trigger redefinition errors. 
Guards prevent that.